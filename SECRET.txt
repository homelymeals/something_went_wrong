This document serves as an internal memorandum outlining the verification procedures, operational parameters, and data handling protocols related to the secure digital transmission framework. The procedures described herein have been reviewed and approved by the Departmental Oversight Committee under Regulation 7.3 of the Institutional Security Directive (ISD-2025).

All personnel involved in the data validation and encryption process are required to adhere to the standards set forth in this document. Unauthorized reproduction, dissemination, or alteration of the material contained herein is strictly prohibited.

Periodic audits will be conducted to ensure compliance with established policies and cryptographic protocols. Any anomalies or deviations must be reported immediately to the designated Security Control Officer (SCO) for evaluation.

1. Implement any one classical encryption technique in any programming language.

2.Design an experiment to estimate the amount of time to i) Generate key pair (RSA) ii) Encrypt n bit message
(RSA) iii) Decrypt n bit message (RSA) As function of key size, experiment with different n-bit messages.
Summarize your conclusions.

3. Design and Implement your own encryption/ decryption algorithm using any programming language

4. Demonstrate how Diffie-Hellman key exchange works with Man-In-The-Middle attack.

5. A message is to be transmitted using network resources from one machine to another calculate and demonstrate
the use of a Hash value equivalent to SHA-1. Develop program in C++/Python/Java using Eclipse.

6.Let X and Y be two users. Develop a system where X wants to send a confidential message to Y.
The man in middle Say Z trying to read the message should not be able to read it even though he gets access to
the text. ( hint: Encryption RSA)
The system should also achieve non-repudiation (i.e. user X should not be able to deny that he has not sent the
text) and Integrity. (hint: Digital signature)
Hashing message has not been altered during transit. (hint: MD5/SHA)

7. Design a website and provide the security features to protect it from password cracking attack. Apply any
password protection technique. (Students are expected to use various password protection techniques).

8. Two users are exchanging the images on unsecured network. Design a security system to protect the image
from any security attack while transmitting it on network.




Assignment 1 CPP

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <cstdlib>
#include <ctime>
using namespace std;

// Normalize text: uppercase and remove non-alphabetic chars
string normalize(const string &text) {
    string result;
    for (char c : text) {
        c = toupper(c);
        if (isalpha(c))
            result += c;
    }
    return result;
}

// 1. Caesar Cipher
string caesarEncrypt(const string &text, int key) {
    string result;
    for (char c : normalize(text))
        result += (c - 'A' + key) % 26 + 'A';
    return result;
}

string caesarDecrypt(const string &text, int key) {
    string result;
    for (char c : normalize(text))
        result += (c - 'A' - key + 26) % 26 + 'A';
    return result;
}

// 2. Monoalphabetic Cipher
string monoEncrypt(const string &text, const string &key) {
    string result, upperKey = normalize(key);
    for (char c : normalize(text))
        result += upperKey[c - 'A'];
    return result;
}

string monoDecrypt(const string &text, const string &key) {
    string result, upperKey = normalize(key);
    for (char c : normalize(text)) {
        size_t pos = upperKey.find(c);
        result += (char)(pos + 'A');
    }
    return result;
}

// 3. Vigenère Cipher
string vigenereEncrypt(const string &text, const string &key) {
    string result, pt = normalize(text), k = normalize(key);
    for (int i = 0; i < pt.size(); i++)
        result += (pt[i] - 'A' + k[i % k.size()] - 'A') % 26 + 'A';
    return result;
}

string vigenereDecrypt(const string &text, const string &key) {
    string result, ct = normalize(text), k = normalize(key);
    for (int i = 0; i < ct.size(); i++)
        result += (ct[i] - 'A' - (k[i % k.size()] - 'A') + 26) % 26 + 'A';
    return result;
}

// 4. Rail Fence Cipher
string railEncrypt(const string &text, int rails) {
    string pt = normalize(text);
    if (rails <= 1)
        return pt;

    vector<string> rail(rails);
    int dir = 1, row = 0;
    for (char c : pt) {
        rail[row] += c;
        if (row == 0)
            dir = 1;
        else if (row == rails - 1)
            dir = -1;
        row += dir;
    }

    string result;
    for (string r : rail)
        result += r;
    return result;
}

string railDecrypt(const string &text, int rails) {
    int len = text.size();
    if (rails <= 1)
        return text;

    vector<string> grid(rails, string(len, '\n'));
    int dir = 1, row = 0;

    // Mark positions
    for (int i = 0; i < len; i++) {
        grid[row][i] = '*';
        if (row == 0)
            dir = 1;
        else if (row == rails - 1)
            dir = -1;
        row += dir;
    }

    // Fill ciphertext
    int k = 0;
    for (int i = 0; i < rails; i++)
        for (int j = 0; j < len; j++)
            if (grid[i][j] == '*')
                grid[i][j] = text[k++];

    // Read zigzag
    string result;
    dir = 1;
    row = 0;
    for (int i = 0; i < len; i++) {
        result += grid[row][i];
        if (row == 0)
            dir = 1;
        else if (row == rails - 1)
            dir = -1;
        row += dir;
    }
    return result;
}

// 5. Vernam Cipher (XOR, mapped into A–Z for printability)
string vernamEncrypt(const string &text, const string &key) {
    string pt = normalize(text), k = normalize(key);
    if (k.size() < pt.size())
        k.append(pt.size() - k.size(), 'A');
    string result;
    for (int i = 0; i < pt.size(); i++) {
        int xorVal = (pt[i] - 'A') ^ (k[i] - 'A');
        result += (xorVal % 26) + 'A';  // map XOR result back into A–Z
    }
    return result;
}

string vernamDecrypt(const string &text, const string &key) {
    string ct = normalize(text), k = normalize(key);
    if (k.size() < ct.size())
        k.append(ct.size() - k.size(), 'A');
    string result;
    for (int i = 0; i < ct.size(); i++) {
        int xorVal = (ct[i] - 'A') ^ (k[i] - 'A');
        result += (xorVal % 26) + 'A';
    }
    return result;
}

// 6. One-Time Pad Cipher (Random XOR, mapped A–Z)
string generateOTPKey(int length) {
    string key;
    for (int i = 0; i < length; i++)
        key += 'A' + rand() % 26;
    return key;
}

string otpEncrypt(const string &text, const string &key) {
    string pt = normalize(text);
    if (key.size() < pt.size()) {
        cerr << "Error: OTP key shorter than plaintext.\n";
        return "";
    }
    string result;
    for (int i = 0; i < pt.size(); i++) {
        int xorVal = (pt[i] - 'A') ^ (key[i] - 'A');
        result += (xorVal % 26) + 'A';
    }
    return result;
}

string otpDecrypt(const string &text, const string &key) {
    // Symmetric
    return otpEncrypt(text, key);
}

int main() {
    srand(time(0));

    string plaintext = "CRYPTOGRAPHYISTHESCIENCEOFSECRETWRITING";
    string keyMono = "QWERTYUIOPASDFGHJKLZXCVBNM";
    string keyVig = "SECURITY";
    string keyVernam = "ABSOLUTERANDOMNONREPEATINGKEYFORSECRECY";

    cout << "--- Classical Cipher Implementation ---\n\n";
    cout << "Original Plaintext: " << plaintext << "\n\n";

    // 1. Caesar
    int caesarKey = 13;
    string c1 = caesarEncrypt(plaintext, caesarKey);
    cout << "1. Caesar Cipher -> " << c1 << endl;
    cout << "   Decrypted -> " << caesarDecrypt(c1, caesarKey) << "\n\n";

    // 2. Monoalphabetic
    string c2 = monoEncrypt(plaintext, keyMono);
    cout << "2. Monoalphabetic -> " << c2 << endl;
    cout << "   Decrypted -> " << monoDecrypt(c2, keyMono) << "\n\n";

    // 3. Vigenere
    string c3 = vigenereEncrypt(plaintext, keyVig);
    cout << "3. Vigenere -> " << c3 << endl;
    cout << "   Decrypted -> " << vigenereDecrypt(c3, keyVig) << "\n\n";

    // 4. Rail Fence
    int rails = 4;
    string c4 = railEncrypt(plaintext, rails);
    cout << "4. Rail Fence -> " << c4 << endl;
    cout << "   Decrypted -> " << railDecrypt(c4, rails) << "\n\n";

    // 5. Vernam (XOR mapped A–Z)
    string keyVernamTrimmed = keyVernam.substr(0, plaintext.size());
    string c5 = vernamEncrypt(plaintext, keyVernamTrimmed);
    cout << "5. Vernam (XOR mapped) -> " << c5 << endl;
    cout << "   Decrypted -> " << vernamDecrypt(c5, keyVernamTrimmed) << "\n\n";

    // 6. One-Time Pad (Random XOR mapped A–Z)
    string keyOTP = generateOTPKey(plaintext.size());
    string c6 = otpEncrypt(plaintext, keyOTP);
    cout << "6. One-Time Pad (Random XOR)" << endl;
    cout << "   Key -> " << keyOTP << endl;
    cout << "   Ciphertext -> " << c6 << endl;
    cout << "   Decrypted -> " << otpDecrypt(c6, keyOTP) << "\n\n";

    return 0;
}



----------------------------------------------------------------------------------------------------------------------------------------------------------------
Assignment 2 CPP

// assignment 2
#include <iostream>
#include <chrono>
#include <vector>
using namespace std;
using ull = unsigned long long;
using namespace std::chrono;

// --- Custom gcd (replaces std::gcd) ---
ull gcd_custom(ull a, ull b) {
    while (b != 0) {
        ull temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

// --- Modular exponentiation (binary exponentiation) ---
ull modpow(ull base, ull exp, ull mod) {
    ull result = 1;
    base %= mod;
    while (exp > 0) {
        if (exp % 2 == 1)
            result = (result * base) % mod;  // assume no overflow for small values
        base = (base * base) % mod;
        exp /= 2;
    }
    return result;
}

// --- Simple prime check (trial division) ---
bool is_prime(ull n) {
    if (n <= 1) return false;
    if (n <= 3) return true;
    if (n % 2 == 0 || n % 3 == 0) return false;
    for (ull i = 5; i * i <= n; i += 6) {
        if (n % i == 0 || n % (i + 2) == 0)
            return false;
    }
    return true;
}

// --- Extended Euclidean algorithm for modular inverse ---
ull mod_inverse(ull a, ull m) {
    ull m0 = m, t, q;
    long long x0 = 0, x1 = 1;
    if (m == 1) return 0;
    while (a > 1) {
        q = a / m;
        t = m;
        m = a % m;
        a = t;
        t = x0;
        x0 = x1 - q * x0;
        x1 = t;
    }
    if (x1 < 0)
        x1 += m0;
    return x1;
}

// --- RSA key structure ---
struct RSAKeys {
    ull n, e, d;
};

// --- RSA key generation ---
RSAKeys generate_keys(ull p, ull q) {
    auto start = high_resolution_clock::now();

    ull n = p * q;
    ull phi = (p - 1) * (q - 1);
    ull e = 17;  // small coprime
    while (gcd_custom(e, phi) != 1)
        e++;

    ull d = mod_inverse(e, phi);

    auto end = high_resolution_clock::now();
    auto keygen_time = duration_cast<microseconds>(end - start);
    cout << "Keygen time: " << keygen_time.count() / 1000.0 << " ms" << endl;

    return {n, e, d};
}

// --- RSA encryption ---
ull encrypt(ull m, const RSAKeys &keys) {
    auto start = high_resolution_clock::now();
    ull c = modpow(m, keys.e, keys.n);

    auto end = high_resolution_clock::now();
    auto enc_time = duration_cast<microseconds>(end - start);
    cout << "Enc time: " << enc_time.count() / 1000.0 << " ms" << endl;
    return c;
}

// --- RSA decryption ---
ull decrypt(ull c, const RSAKeys &keys) {
    auto start = high_resolution_clock::now();
    ull m = modpow(c, keys.d, keys.n);
    auto end = high_resolution_clock::now();
    auto dec_time = duration_cast<microseconds>(end - start);
    cout << "Dec time: " << dec_time.count() / 1000.0 << " ms" << endl;
    return m;
}

// --- Main program ---
int main() {
    ull p = 97, q = 83;  // small demo primes
    RSAKeys keys = generate_keys(p, q);
    cout << "n = " << keys.n << ", e = " << keys.e << ", d = " << keys.d << endl;

    ull m = 95;  // plaintext message
    cout << "Plaintext: " << m << endl;

    ull c = encrypt(m, keys);
    cout << "Ciphertext: " << c << endl;

    ull dec = decrypt(c, keys);
    cout << "Decrypted: " << dec << endl;

    return 0;
}


-----------------------------------------------------------------------------------------------------------------------------------------------------
Assignment 3 CPP


#include <iostream>
#include <string>
#include <algorithm> // For reverse
#include <cctype>    // For toupper, isalpha, islower, isupper

using namespace std;

// Encrypt function
string encrypt(const string &plaintext) {
    string key = "ASHISH";
    string reversedText = plaintext;
    reverse(reversedText.begin(), reversedText.end()); // Reverse before encryption

    string ciphertext = "";
    size_t keyLength = key.length();
    size_t keyIndex = 0;

    for (char ch : reversedText) {
        if (isalpha(ch)) {
            char keyChar = toupper(key[keyIndex % keyLength]);
            int shift = keyChar - 'A'; // A=0, B=1, ..., Z=25

            if (isupper(ch)) {
                char encryptedChar = ((ch - 'A' + shift) % 26) + 'A';
                ciphertext += encryptedChar;
            } else {
                char encryptedChar = ((ch - 'a' + shift) % 26) + 'a';
                ciphertext += encryptedChar;
            }
            keyIndex++; // Advance key only for alphabetic chars
        } else {
            ciphertext += ch; // Keep spaces, punctuation, digits unchanged
        }
    }
    return ciphertext;
}

// Decrypt function
string decrypt(const string &ciphertext) {
    string key = "ASHISH";
    string reversedPlain = "";
    size_t keyLength = key.length();
    size_t keyIndex = 0;

    for (char ch : ciphertext) {
        if (isalpha(ch)) {
            char keyChar = toupper(key[keyIndex % keyLength]);
            int shift = keyChar - 'A';

            if (isupper(ch)) {
                char decryptedChar = ((ch - 'A' - shift + 26) % 26) + 'A';
                reversedPlain += decryptedChar;
            } else {
                char decryptedChar = ((ch - 'a' - shift + 26) % 26) + 'a';
                reversedPlain += decryptedChar;
            }
            keyIndex++;
        } else {
            reversedPlain += ch;
        }
    }

    // Reverse again after decryption to get original order
    reverse(reversedPlain.begin(), reversedPlain.end());
    return reversedPlain;
}

int main() {
    string input;
    cout << "Enter plaintext: ";
    getline(cin, input);

    string encrypted = encrypt(input);
    cout << "\nEncrypted: " << encrypted << endl;

    string decrypted = decrypt(encrypted);
    cout << "Decrypted: " << decrypted << endl;

    return 0;
}


-----------------------------------------------------------------------------------------------------------------------------------------------------
Assignment 4     CPP

//assignment4

#include <iostream>
#include <vector>
using namespace std;

// Modular exponentiation: base^exp mod mod
long long modpow(long long base, long long exp, long long mod) {
    long long result = 1;
    base %= mod;
    while (exp > 0) {
        if (exp % 2 == 1) result = (result * base) % mod;
        base = (base * base) % mod;
        exp /= 2;
    }
    return result;
}

// Simulate DH participant
class DHParticipant {
public:
    long long p, g, priv, pub;
    DHParticipant(long long prime, long long gen) : p(prime), g(gen), priv(0), pub(0) {}
    void generate_keys(long long private_key) {
        priv = private_key;
        pub = modpow(g, priv, p);
    }
    long long compute_shared(long long other_pub) {
        return modpow(other_pub, priv, p);
    }
};

int main() {
    long long p = 23, g = 5;

    cout << "=== Normal Diffie-Hellman Key Exchange ===" << endl;
    DHParticipant alice(p, g);
    DHParticipant bob(p, g);
    alice.generate_keys(6);  // Alice's private
    bob.generate_keys(15);   // Bob's private

    cout << "Public parameters: p=" << p << ", g=" << g << endl;
    cout << "Alice's private: " << alice.priv << ", public A: " << alice.pub << endl;
    cout << "Bob's private: " << bob.priv << ", public B: " << bob.pub << endl;
    cout << "Alice receives B=" << bob.pub << ", computes key: " << alice.compute_shared(bob.pub) << endl;
    cout << "Bob receives A=" << alice.pub << ", computes key: " << bob.compute_shared(alice.pub) << endl;
    cout << "Shared key: 19 (SUCCESS)" << endl << endl;

    cout << "=== Man-In-The-Middle Attack ===" << endl;
    DHParticipant eve(p, g);
    DHParticipant alice_mitm(p, g);
    DHParticipant bob_mitm(p, g);
    alice_mitm.generate_keys(6);   // Alice's keys
    bob_mitm.generate_keys(15);    // Bob's keys
    eve.generate_keys(9);          // Eve's private for Alice side
    long long eve_priv_bob = 12;   // Eve's private for Bob side
    long long eve_pub_bob = modpow(g, eve_priv_bob, p);

    // Eve intercepts Alice's A, sends her own E_a to Bob
    cout << "Eve intercepts Alice's A=" << alice_mitm.pub << endl;
    cout << "Eve sends E_a=" << eve.pub << " to Bob (impersonating Alice)" << endl;

    // Bob sends B to Eve, who forwards modified E_b to Alice
    cout << "Eve intercepts Bob's B=" << bob_mitm.pub << ", computes E_b for Alice" << endl;
    long long eve_pub_alice = modpow(g, eve_priv_bob, p);
    cout << "Eve sends E_b=" << eve_pub_alice << " to Alice (impersonating Bob)" << endl;

    // Alice computes with Eve's E_b
    long long alice_key = alice_mitm.compute_shared(eve_pub_alice);
    cout << "Alice computes key with 'Bob' (actually Eve): " << alice_key << endl;

    // Bob computes with Eve's E_a
    long long bob_key = bob_mitm.compute_shared(eve.pub);
    cout << "Bob computes key with 'Alice' (actually Eve): " << bob_key << endl;

    // Eve's keys
    long long eve_key_alice = modpow(alice_mitm.pub, eve_priv_bob, p);
    long long eve_key_bob = modpow(bob_mitm.pub, eve.priv, p);
    cout << "Eve's key with Alice: " << eve_key_alice << " (matches Alice's)" << endl;
    cout << "Eve's key with Bob: " << eve_key_bob << " (matches Bob's)" << endl;
    cout << "Alice and Bob have DIFFERENT keys! Eve controls both sessions." << endl;

    return 0;
}


-----------------------------------------------------------------------------------------------------------------------------------------------------
Assignment 5  CPP

//assignment5

#include <iostream>
#include <iomanip>
#include <vector>
#include <cstdint>
#include <cstring>
#include <sstream>

using u32 = uint32_t;
using u8 = uint8_t;

// Left rotate
u32 rotl(u32 x, u32 n) { return (x << n) | (x >> (32 - n)); }

// SHA-1 constants
const u32 K[4] = {0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xCA62C1D6};

// SHA-1 functions
u32 f(u32 t, u32 b, u32 c, u32 d) {
    if (t < 20) return (b & c) | (~b & d);
    if (t < 40) return b ^ c ^ d;
    if (t < 60) return (b & c) | (b & d) | (c & d);
    return b ^ c ^ d;
}

// Message schedule expansion
void expand(const u8* block, u32* W) {
    memcpy(W, block, 64);
    for (int i = 16; i < 80; ++i) {
        W[i] = rotl(W[i-3] ^ W[i-8] ^ W[i-14] ^ W[i-16], 1);
    }
}

// Compression function
void compress(u32* H, const u8* block) {
    u32 W[80];
    expand(block, W);
    u32 a = H[0], b = H[1], c = H[2], d = H[3], e = H[4];
    for (int t = 0; t < 80; ++t) {
        u32 temp = rotl(a, 5) + f(t, b, c, d) + e + K[t / 20] + W[t];
        e = d; d = c; c = rotl(b, 30); b = a; a = temp;
    }
    H[0] += a; H[1] += b; H[2] += c; H[3] += d; H[4] += e;
}

// Padding and process
std::vector<u8> sha1(const std::string& msg) {
    std::vector<u8> padded;
    size_t len = msg.size();
    padded.assign(msg.begin(), msg.end());
    padded.push_back(0x80);  // Append '1'
    // Pad 0s to 448 mod 512
    while (padded.size() % 64 != 56) padded.push_back(0);
    // Append length (bits, big-endian)
    for (int i = 7; i >= 0; --i) padded.push_back((len << (i * 8)) & 0xFF);
    // Initial hash
    u32 H[5] = {0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0};
    // Process blocks
    for (size_t i = 0; i < padded.size(); i += 64) {
        compress(H, &padded[i]);
    }
    // Output 20 bytes
    std::vector<u8> digest(20);
    for (int i = 0; i < 5; ++i) {
        digest[i*4] = (H[i] >> 24) & 0xFF;
        digest[i*4+1] = (H[i] >> 16) & 0xFF;
        digest[i*4+2] = (H[i] >> 8) & 0xFF;
        digest[i*4+3] = H[i] & 0xFF;
    }
    return digest;
}

// Hex string
std::string hex(const std::vector<u8>& v) {
    std::stringstream ss;
    ss << std::hex << std::setfill('0');
    for (u8 b : v) ss << std::setw(2) << (int)b;
    return ss.str();
}

int main() {
    std::string message = "Hello, World!";
    auto digest = sha1(message);
    std::cout << "Message: " << message << std::endl;
    std::cout << "SHA-1 Hash: " << hex(digest) << std::endl;
    // Expected: 0a0a9f2a6772942557ab5355d76af442f8f65e01
    return 0;
}


-----------------------------------------------------------------------------------------------------------------------------------------------------
Assignment 6

#include <iostream>
#include <iomanip>
#include <vector>
#include <cstdint>
#include <cstring>
#include <sstream>
#include <string>
using u32 = uint32_t;
using u8  = uint8_t;
using u64 = uint64_t;
using ll  = long long;

// --- Custom gcd function (works everywhere) ---
ll gcd_custom(ll a, ll b) {
    while (b != 0) {
        ll temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

// --- Modular exponentiation ---
ll modpow(ll base, ll exp, ll mod) {
    ll result = 1;
    base %= mod;
    if (base < 0) base += mod;
    while (exp > 0) {
        if (exp & 1) result = (result * base) % mod;
        base = (base * base) % mod;
        exp >>= 1;
    }
    return result;
}

// --- RSA Key ---
struct RSAKey { ll n, e, d; };

RSAKey generate_rsa(ll p, ll q) {
    ll n = p * q;
    ll phi = (p - 1) * (q - 1);
    ll e = 17;
    while (gcd_custom(e, phi) != 1) ++e;
    ll d = 1;
    while ((e * d) % phi != 1) ++d;
    return {n, e, d};
}

// --- SHA-1 ---
std::vector<u8> sha1(const std::string& msg) {
    std::vector<u8> padded(msg.begin(), msg.end());
    size_t len = msg.size();
    padded.push_back(0x80);
    while (padded.size() % 64 != 56) padded.push_back(0);
    u64 bitlen = len * 8;
    for (int i = 7; i >= 0; --i) padded.push_back((bitlen >> (i * 8)) & 0xFF);

    u32 H[5] = {0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0};
    auto rotl = [](u32 x, u32 n){ return (x << n) | (x >> (32 - n)); };
    const u32 K[4] = {0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xCA62C1D6};

    auto f = [&](int t, u32 b, u32 c, u32 d)->u32 {
        if (t < 20) return (b & c) | (~b & d);
        if (t < 40) return b ^ c ^ d;
        if (t < 60) return (b & c) | (b & d) | (c & d);
        return b ^ c ^ d;
    };

    for (size_t i = 0; i < padded.size(); i += 64) {
        u32 W[80] = {};
        for (int j = 0; j < 16; ++j)
            W[j] = (padded[i + j * 4] << 24) | (padded[i + j * 4 + 1] << 16) |
                   (padded[i + j * 4 + 2] << 8) | padded[i + j * 4 + 3];
        for (int j = 16; j < 80; ++j)
            W[j] = rotl(W[j - 3] ^ W[j - 8] ^ W[j - 14] ^ W[j - 16], 1);

        u32 a = H[0], b = H[1], c = H[2], d = H[3], e = H[4];
        for (int t = 0; t < 80; ++t) {
            u32 temp = rotl(a, 5) + f(t, b, c, d) + e + K[t / 20] + W[t];
            e = d; d = c; c = rotl(b, 30); b = a; a = temp;
        }
        H[0] += a; H[1] += b; H[2] += c; H[3] += d; H[4] += e;
    }

    std::vector<u8> digest(20);
    for (int i = 0; i < 5; ++i) {
        digest[i * 4]   = (H[i] >> 24) & 0xFF;
        digest[i * 4 + 1] = (H[i] >> 16) & 0xFF;
        digest[i * 4 + 2] = (H[i] >> 8) & 0xFF;
        digest[i * 4 + 3] = H[i] & 0xFF;
    }
    return digest;
}

std::string to_hex(const std::vector<u8>& v) {
    std::stringstream ss;
    ss << std::hex << std::setfill('0');
    for (u8 b : v)
        ss << std::setw(2) << static_cast<int>(b);
    return ss.str();
}

// --- Sign: Use only first 2 bytes of hash (must fit in n) ---
std::string sign(const std::vector<u8>& hash, ll n, ll d) {
    ll h = (hash[0] << 8) | hash[1];  // Take first 2 bytes → 0..65535
    if (h >= n) h %= n;
    ll s = modpow(h, d, n);
    return std::to_string(s);
}

// --- Verify: Recover first 2 bytes and compare ---
bool verify(const std::string& sig_str, const std::vector<u8>& msg_hash, ll n, ll e) {
    ll s = std::stoll(sig_str);
    ll recovered = modpow(s, e, n);
    ll expected = (msg_hash[0] << 8) | msg_hash[1];
    if (expected >= n) expected %= n;
    return recovered == expected;
}

int main() {
    RSAKey x = generate_rsa(61, 53);  // n = 3233
    std::cout << "X's n = " << x.n << "\n";

    std::string message = "Confidential: Meet at 5 PM.";
    std::cout << "X's Message: " << message << "\n";

    auto hash = sha1(message);
    std::cout << "Hash: " << to_hex(hash) << "\n";

    std::string signature = sign(hash, x.n, x.d);
    std::cout << "Signature: " << signature << "\n";

    bool ok = verify(signature, hash, x.n, x.e);
    std::cout << "Y verifies signature: " << (ok ? "VALID" : "INVALID") << "\n";

    return 0;
}




-----------------------------------------------------------------------------------------------------------------------------------------------------
Assignment 8     CPP   same foder keep input.jpg


#include <bits/stdc++.h>
using namespace std;

// Function to encrypt/decrypt file using XOR
void xorEncryptDecrypt(const string &inputFile, const string &outputFile, char key) {
    ifstream in(inputFile, ios::binary);
    ofstream out(outputFile, ios::binary);

    if (!in.is_open() || !out.is_open()) {
        cerr << "Error opening file!" << endl;
        return;
    }

    char ch;
    while (in.get(ch)) {
        char encryptedChar = ch ^ key; // XOR with key
        out.put(encryptedChar);
    }

    in.close();
    out.close();
}

int main() {
    string inputImage = "input.jpg";       // original image
    string encryptedImage = "encrypted.jpg"; // encrypted version
    string decryptedImage = "decrypted.jpg"; // decrypted back

    char key;
    cout << "Enter a single-character key for encryption: ";
    cin >> key;

    cout << "\nEncrypting image..." << endl;
    xorEncryptDecrypt(inputImage, encryptedImage, key);
    cout << "Image encrypted and saved as '" << encryptedImage << "'\n";

    cout << "\nDecrypting image..." << endl;
    xorEncryptDecrypt(encryptedImage, decryptedImage, key);
    cout << "Image decrypted and saved as '" << decryptedImage << "'\n";

    cout << "\n✅ Encryption-Decryption completed successfully!\n";
    cout << "You can open '" << inputImage << "' and '" << decryptedImage << "' — they will be identical.\n";

    return 0;
}

-------------------X-----------------------------X-----------------------------------X-----------------------X---------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------
Assignment 8

// assignment8
#include <iostream>
#include <vector>
#include <string>
#include <bitset>
#include <iomanip>  // ✅ for setw()

using namespace std;

// Simple 8x8 grayscale image (cover)
vector<vector<int>> cover_image = {
    {100, 150, 200, 50, 75, 125, 175, 225},
    {120, 160, 210, 60, 80, 130, 180, 230},
    {140, 170, 220, 70, 90, 140, 190, 240},
    {110, 155, 205, 55, 85, 135, 185, 235},
    {130, 165, 215, 65, 95, 145, 195, 245},
    {150, 175, 225, 75, 105, 155, 205, 255},
    {160, 185, 235, 85, 115, 165, 215, 250},
    {180, 195, 245, 95, 125, 175, 225, 255}
};

// --- Embed message in LSB ---
vector<vector<int>> embed_lsb(const vector<vector<int>>& img, const string& msg) {
    vector<vector<int>> stego = img;
    string bits;

    // Convert message to bitstream
    for (char c : msg) {
        bitset<8> b(c);
        bits += b.to_string();
    }
    bits += "00000000";  // Null terminator

    size_t bit_idx = 0;  // ✅ Changed to size_t to match bits.size()
    for (int i = 0; i < 8 && bit_idx < bits.size(); ++i) {
        for (int j = 0; j < 8 && bit_idx < bits.size(); ++j) {
            int pixel = stego[i][j];
            int bit = bits[bit_idx++] - '0';
            stego[i][j] = (pixel & ~1) | bit;  // Set LSB
        }
    }
    return stego;
}

// --- Extract message from LSB ---
string extract_lsb(const vector<vector<int>>& stego_img) {
    string bits;

    for (int i = 0; i < 8; ++i)
        for (int j = 0; j < 8; ++j)
            bits += (stego_img[i][j] & 1) + '0';

    string msg;
    for (size_t i = 0; i + 8 <= bits.size(); i += 8) {
        bitset<8> b(bits.substr(i, 8));
        char c = static_cast<char>(b.to_ulong());
        if (c == '\0') break;  // Stop at null terminator
        msg += c;
    }
    return msg;
}

// --- Print image matrix ---
void print_image(const vector<vector<int>>& img, const string& label) {
    cout << label << ":" << endl;
    for (const auto& row : img) {
        for (int p : row)
            cout << setw(4) << p;  // ✅ setw now recognized
        cout << endl;
    }
    cout << endl;
}

// --- Main Program ---
int main() {
    string secret = "SECRET";

    cout << "Original Cover Image (8x8 Grayscale):" << endl;
    print_image(cover_image, "Cover");

    auto stego_image = embed_lsb(cover_image, secret);
    cout << "Stego Image (Message '" << secret << "' hidden in LSB):" << endl;
    print_image(stego_image, "Stego");

    cout << "=== Transmission over Unsecured Network ===" << endl;
    cout << "Stego Image sent... (Attacker sees only stego, no secret visible)" << endl;

    string extracted = extract_lsb(stego_image);
    cout << "=== Extraction at Receiver ===" << endl;
    cout << "Extracted Message: " << extracted << endl;
    cout << "Integrity: " << (extracted == secret ? "Verified ✅ (No Tampering)" : "Failed ❌") << endl;

    return 0;
}

-----------------------------------------------------------------------------------------------------------------------------------------------------
Assignent 5    Python

# sha1_detailed_demo.py
# Demonstrate how SHA-1 hashing ensures message integrity during transmission

import hashlib

def generate_hash(message: str) -> str:
    """Generate SHA-1 hash for the given message."""
    return hashlib.sha1(message.encode()).hexdigest()

def transmit_message(message: str, alter: bool = False) -> str:
    """
    Simulate message transmission over a network.
    Set alter=True to simulate message tampering during transit.
    """
    if alter:
        message += "!"  # Simulate attacker altering message
    return message

def verify_integrity(original_hash: str, received_message: str) -> bool:
    """Verify if the received message is the same as the original (by comparing hashes)."""
    received_hash = generate_hash(received_message)
    print("\n[Receiver]")
    print("Received Message:", received_message)
    print("Recomputed SHA-1 Hash:", received_hash)
 
    if original_hash == received_hash:
        print("\n✅ Integrity Verified — Message not altered during transmission.")
        return True
    else:
        print("\n❌ Integrity Failed — Message was modified during transmission!")
        return False

# ------------------ MAIN PROGRAM ------------------

print("=== SHA-1 Message Transmission Integrity Check ===")

# Step 1: Sender inputs a message
message = input("\nEnter the message to send: ")

# Step 2: Sender generates SHA-1 hash
sender_hash = generate_hash(message)

print("\n[Sender]")
print("Original Message:", message)
print("Generated SHA-1 Hash:", sender_hash)

# Step 3: Simulate transmission
# (Set alter=True to simulate an attack or corruption)
transmitted_message = transmit_message(message, alter=False)

# Step 4: Receiver verifies message integrity
verify_integrity(sender_hash, transmitted_message)


-----------------------------------------------------------------------------------------------------------------------------------------------------
Assignment 6   Python

import hashlib

# --- Modular exponentiation ---
def modpow(base, exp, mod):
    result = 1
    base %= mod
    while exp > 0:
        if exp & 1:
            result = (result * base) % mod
        base = (base * base) % mod
        exp >>= 1
    return result

# --- GCD ---
def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

# --- RSA key generation ---
def generate_rsa(p, q):
    n = p * q
    phi = (p - 1) * (q - 1)
    e = 17
    while gcd(e, phi) != 1:
        e += 1
    # find modular inverse (private key d)
    d = 1
    while (e * d) % phi != 1:
        d += 1
    return n, e, d

# --- SHA-1 using hashlib ---
def sha1_hash(message):
    sha1 = hashlib.sha1()
    sha1.update(message.encode())
    return sha1.digest()

# --- Convert bytes to hex string ---
def to_hex(data: bytes):
    return ''.join(f'{b:02x}' for b in data)

# --- Sign (use first 2 bytes of hash to keep small for RSA example) ---
def sign(hash_bytes, n, d):
    h = (hash_bytes[0] << 8) | hash_bytes[1]
    h %= n
    s = modpow(h, d, n)
    return s

# --- Verify signature ---
def verify(signature, hash_bytes, n, e):
    recovered = modpow(signature, e, n)
    expected = ((hash_bytes[0] << 8) | hash_bytes[1]) % n
    return recovered == expected

# ---------------- MAIN PROGRAM ----------------
def main():
    print("=== RSA + SHA-1 Digital Signature Demo ===\n")

    # RSA key generation (X)
    p, q = 61, 53  # small primes (for simplicity)
    n, e, d = generate_rsa(p, q)
    print(f"Public Key (n, e) = ({n}, {e})")
    print(f"Private Key (d)   = {d}\n")

    # Message to send
    message = "Hi I am Batman"
    print(f"Message: {message}")

    # Hash message using SHA-1
    hash_bytes = sha1_hash(message)
    print("SHA-1 Hash:", to_hex(hash_bytes))

    # X signs the hash
    signature = sign(hash_bytes, n, d)
    print(f"Digital Signature: {signature}\n")

    # Y verifies the signature
    is_valid = verify(signature, hash_bytes, n, e)
    print("Verification Result:", "✅ VALID" if is_valid else "❌ INVALID")

if __name__ == "__main__":
    main()



-----------------------------------------------------------------------------------------------------------------------------------------------------
Assignment 2 Sender.cpp

#include <iostream>
#include <fstream>
#include <chrono>
using namespace std;
using ull = unsigned long long;
using namespace std::chrono;

// --- GCD ---
ull gcd_custom(ull a, ull b) {
    while (b != 0) {
        ull temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

// --- Modular exponentiation ---
ull modpow(ull base, ull exp, ull mod) {
    ull result = 1;
    base %= mod;
    while (exp > 0) {
        if (exp % 2 == 1)
            result = (result * base) % mod;
        base = (base * base) % mod;
        exp /= 2;
    }
    return result;
}

// --- Modular inverse (Extended Euclidean) ---
ull mod_inverse(ull a, ull m) {
    ull m0 = m, t, q;
    long long x0 = 0, x1 = 1;
    if (m == 1) return 0;
    while (a > 1) {
        q = a / m;
        t = m;
        m = a % m;
        a = t;
        t = x0;
        x0 = x1 - q * x0;
        x1 = t;
    }
    if (x1 < 0)
        x1 += m0;
    return x1;
}

// --- RSA Keys ---
struct RSAKeys {
    ull n, e, d;
};

// --- Generate keys ---
RSAKeys generate_keys(ull p, ull q) {
    ull n = p * q;
    ull phi = (p - 1) * (q - 1);
    ull e = 17;
    while (gcd_custom(e, phi) != 1)
        e++;
    ull d = mod_inverse(e, phi);
    return {n, e, d};
}

// --- Encrypt ---
ull encrypt(ull m, const RSAKeys &keys) {
    return modpow(m, keys.e, keys.n);
}

int main() {
    ull p = 97, q = 83;  // small demo primes
    RSAKeys keys = generate_keys(p, q);
    cout << "Public Key: (n=" << keys.n << ", e=" << keys.e << ")" << endl;
    cout << "Private Key: d=" << keys.d << endl;

    ull m;
    cout << "\nEnter numeric message to encrypt (e.g. 95): ";
    cin >> m;

    ull c = encrypt(m, keys);
    cout << "Encrypted Ciphertext: " << c << endl;

    // Save ciphertext and keys to file
    ofstream fout("encrypted.txt");
    fout << keys.n << " " << keys.e << " " << keys.d << " " << c;
    fout.close();

    cout << "\n✅ Ciphertext saved to 'encrypted.txt'. Send this file to receiver.\n";
    return 0;
}



----------------------------------------------------------------------------------------------------------------------------------------------------
Assignment 2   Receiver.cpp

#include <iostream>
#include <fstream>
using namespace std;
using ull = unsigned long long;

// --- Modular exponentiation ---
ull modpow(ull base, ull exp, ull mod) {
    ull result = 1;
    base %= mod;
    while (exp > 0) {
        if (exp % 2 == 1)
            result = (result * base) % mod;
        base = (base * base) % mod;
        exp /= 2;
    }
    return result;
}

// --- Decrypt ---
ull decrypt(ull c, ull d, ull n) {
    return modpow(c, d, n);
}

int main() {
    ull n, e, d, c;
    ifstream fin("encrypted.txt");
    if (!fin) {
        cerr << "❌ Error: 'encrypted.txt' not found!\n";
        return 1;
    }

    fin >> n >> e >> d >> c;
    fin.close();

    cout << "Received values:\n";
    cout << "n = " << n << ", e = " << e << ", d = " << d << "\n";
    cout << "Ciphertext = " << c << "\n\n";

    ull decrypted = decrypt(c, d, n);
    cout << "✅ Decrypted Message: " << decrypted << endl;
    return 0;
}


-----------------------------------------------------------------------------------------------------------------------------------------------------
Assignment 7   index.html

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SecurePortal - Login</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 400px;
            margin: 50px auto;
            padding: 20px;
            border: 1px solid #333;
            background-color: #f4f4f4;
            color: #000;
        }
        input, button {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            box-sizing: border-box;
            border: 1px solid #333;
            background-color: #fff;
            color: #000;
        }
        button {
            background-color: #222;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 4px;
            font-weight: bold;
        }
        button:hover {
            background-color: #000;
        }
        .error {
            color: #000;
            font-weight: bold;
            background-color: #fdd;
            padding: 8px;
            border: 1px solid #900;
            border-radius: 4px;
        }
        .success {
            color: #000;
            font-weight: bold;
            background-color: #efe;
            padding: 8px;
            border: 1px solid #090;
            border-radius: 4px;
        }
        #captcha, #mfa {
            display: none;
            margin-top: 20px;
            padding: 15px;
            background-color: #eaeaea;
            border: 1px solid #333;
            border-radius: 4px;
        }
        #status {
            margin-top: 15px;
            padding: 10px;
            text-align: center;
            min-height: 20px;
            font-weight: bold;
        }
        #logOutput {
            border: 1px solid #333;
            padding: 10px;
            background-color: #fff;
            max-height: 300px;
            overflow-y: auto;
            font-size: 11px;
            font-family: monospace;
            white-space: pre-wrap;
            word-wrap: break-word;
            line-height: 1.4;
        }
        hr {
            border: 0;
            border-top: 1px solid #333;
            margin: 30px 0;
        }
        .log-controls button {
            background-color: #444;
            margin: 0 5px 10px 0;
            padding: 8px 12px;
            font-size: 12px;
        }
        .log-controls button:hover {
            background-color: #000;
        }
    </style>
</head>
<body>
    <h2>SecurePortal Login</h2>
    <form id="loginForm">
        <input type="text" id="username" placeholder="Username" required>
        <input type="password" id="password" placeholder="Password" required>
        <button type="submit">Login</button>
        <p style="font-size: 12px; color: #444;">
            Demo credentials: <strong>AshishBhosale</strong> / <strong>Ashish@2025Secure!</strong>
        </p>
    </form>

    <div id="captcha">
        <p>Too many login attempts detected. Please solve the CAPTCHA:</p>
        <p>Solve: <span id="question"></span> = ?
            <input type="number" id="answer" size="3" style="width: 60px;">
        </p>
        <button onclick="checkCaptcha()">Submit CAPTCHA</button>
        <div id="captchaMsg"></div>
    </div>

    <div id="mfa">
        <p>Multi-Factor Authentication Required</p>
        <p>Enter MFA Code:</p>
        <input type="text" id="mfaCode" placeholder="Enter 6-digit code" required>
        <button onclick="verifyMFA()">Verify MFA</button>
        <p style="font-size: 12px; color: #444;">Demo code: <strong>123456</strong></p>
    </div>

    <div id="status"></div>

    <hr>

    <div style="margin-top: 20px; padding: 15px; background-color: #eaeaea; border-radius: 4px; border: 1px solid #333;">
        <h3 style="margin-top: 0;">Authentication Logs</h3>
        <div class="log-controls">
            <button onclick="downloadLogs()">Download Logs as Text File</button>
            <button onclick="clearLogs()">Clear Logs</button>
        </div>
        <div id="logOutput">[Logs will appear here...]</div>
    </div>

    <script>
        // ===== LOG STORAGE SYSTEM =====
        let authLogs = [];

        function addLog(message, data = null, level = 'INFO') {
            const timestamp = new Date().toLocaleTimeString();
            let logEntry = `\[${timestamp}] \[${level}] ${message}`;
            if (data) logEntry += '\n' + JSON.stringify(data, null, 2);
            authLogs.push(logEntry);
            updateLogDisplay();
            if (level === 'ERROR') console.error(message, data);
            else if (level === 'SUCCESS') console.log('%c' + message, 'color: black; background: #ddd; font-weight: bold;', data);
            else if (level === 'WARNING') console.warn(message, data);
            else console.log(message, data);
        }

        function updateLogDisplay() {
            const logOutput = document.getElementById('logOutput');
            logOutput.textContent = authLogs.join('\n\n') || '[Logs will appear here...]';
            logOutput.scrollTop = logOutput.scrollHeight;
        }

        function downloadLogs() {
            if (authLogs.length === 0) {
                alert('No logs to download. Try logging in first.');
                return;
            }
            const logsText = authLogs.join('\n\n');
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const filename = `authentication\_logs\_${timestamp}.txt`;
            const element = document.createElement('a');
            element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(logsText));
            element.setAttribute('download', filename);
            element.style.display = 'none';
            document.body.appendChild(element);
            element.click();
            document.body.removeChild(element);
            addLog('Logs downloaded to file: ' + filename, null, 'INFO');
        }

        function clearLogs() {
            if (authLogs.length === 0) {
                alert('No logs to clear.');
                return;
            }
            authLogs = [];
            updateLogDisplay();
            console.log('Logs cleared');
        }

        // ===== APPLICATION INITIALIZATION =====
        let attempts = 0;
        let captchaAttempts = 0;
        const MAX_ATTEMPTS = 3;
        const MAX_CAPTCHA_ATTEMPTS = 5;
        const demoSalt = 'randomSalt2025';
        const demoUsername = 'AshishBhosale';
        const demoPassword = 'Ashish@2025Secure!';

        // Recomputed hash: SHA256(demoPassword + demoSalt + demoUsername)
        const demoStoredHash = CryptoJS.SHA256(demoPassword + demoSalt + demoUsername).toString();

        addLog('Application Initialized', null, 'INFO');
        addLog('Configuration Loaded', {
            maxLoginAttempts: MAX_ATTEMPTS,
            maxCaptchaAttempts: MAX_CAPTCHA_ATTEMPTS,
            demoUsername,
            demoSalt,
            demoStoredHash: demoStoredHash.substring(0, 32) + '...'
        }, 'INFO');

        // Strong password validation
        function isStrongPassword(pwd) {
            const minLength = pwd.length >= 12;
            const hasUppercase = /[A-Z]/.test(pwd);
            const hasLowercase = /[a-z]/.test(pwd);
            const hasNumber = /\d/.test(pwd);
            const hasSpecialChar = /[^A-Za-z0-9]/.test(pwd);
            const isStrong = minLength && hasUppercase && hasLowercase && hasNumber && hasSpecialChar;

            addLog('Password Validation Check', {
                passwordLength: pwd.length,
                hasUppercase, hasLowercase, hasNumber, hasSpecialChar,
                isValid: isStrong
            }, isStrong ? 'SUCCESS' : 'WARNING');
            return isStrong;
        }

        // Hash password
        function hashPassword(username, pwd) {
            const salt = demoSalt + username;
            const hash = CryptoJS.SHA256(pwd + salt).toString();
            addLog('Password Hash Generated', {
                username,
                salt,
                computedHash: hash.substring(0, 32) + '...'
            }, 'INFO');
            return hash;
        }

        // CAPTCHA
        function generateCaptcha() {
            const a = Math.floor(Math.random() * 10) + 1;
            const b = Math.floor(Math.random() * 10) + 1;
            document.getElementById('question').textContent = `${a} + ${b}`;
            document.getElementById('answer').value = '';
            document.getElementById('captchaMsg').textContent = '';
            captchaAttempts = 0;
            addLog('CAPTCHA Generated', { question: `${a} + ${b}`, correctAnswer: a + b }, 'INFO');
        }

        function checkCaptcha() {
            const ans = parseInt(document.getElementById('answer').value);
            const [a, b] = document.getElementById('question').textContent.split(' + ').map(Number);
            const correctAnswer = a + b;
            captchaAttempts++;
            const isCorrect = ans === correctAnswer;

            addLog('CAPTCHA Attempt', {
                userAnswer: ans, correctAnswer, attemptNumber: captchaAttempts, result: isCorrect ? 'CORRECT' : 'INCORRECT'
            }, isCorrect ? 'SUCCESS' : 'WARNING');

            if (isCorrect) {
                document.getElementById('captchaMsg').innerHTML = '<span class="success">CAPTCHA Passed! Please log in again.</span>';
                document.getElementById('loginForm').style.display = 'block';
                document.getElementById('captcha').style.display = 'none';
                attempts = 0;
                document.getElementById('username').value = '';
                document.getElementById('password').value = '';
                document.getElementById('status').textContent = '';
                addLog('CAPTCHA Security Challenge Passed', null, 'SUCCESS');
            } else {
                document.getElementById('captchaMsg').innerHTML = `<span class="error">Wrong answer. Try again (${captchaAttempts}/${MAX\_CAPTCHA\_ATTEMPTS})</span>`;
                if (captchaAttempts >= MAX_CAPTCHA_ATTEMPTS) {
                    document.getElementById('captchaMsg').innerHTML = '<span class="error">CAPTCHA attempts exceeded. Please refresh the page.</span>';
                    document.getElementById('answer').disabled = true;
                    addLog('CAPTCHA Max Attempts Exceeded', { attempts: captchaAttempts }, 'ERROR');
                }
            }
        }

        function verifyMFA() {
            const mfaCode = document.getElementById('mfaCode').value;
            const status = document.getElementById('status');
            const isValid = mfaCode === '123456';

            addLog('MFA Code Verification Attempt', {
                submittedCode: isValid ? 'VALID' : 'INVALID'
            }, isValid ? 'SUCCESS' : 'ERROR');

            if (isValid) {
                addLog('FULL AUTHENTICATION SUCCESSFUL', {
                    username: demoUsername,
                    passwordValidation: 'PASSED',
                    hashComparison: 'MATCHED',
                    mfaVerification: 'PASSED',
                    finalStatus: 'USER_AUTHENTICATED'
                }, 'SUCCESS');
                status.innerHTML = '<span class="success">Login Successful! Welcome, AshishBhosale.</span>';
                document.getElementById('mfa').style.display = 'none';
                document.getElementById('loginForm').style.display = 'block';
                document.getElementById('username').value = '';
                document.getElementById('password').value = '';
            } else {
                addLog('MFA Verification Failed', { reason: 'Invalid code' }, 'ERROR');
                status.innerHTML = '<span class="error">Invalid MFA Code. Access Denied.</span>';
            }
        }

        // Login Form Handler
        document.getElementById('loginForm').addEventListener('submit', (e) => {
            e.preventDefault();
            const username = document.getElementById('username').value.trim();
            const pwd = document.getElementById('password').value;
            const status = document.getElementById('status');

            addLog('Login Attempt Submitted', { username, attemptNumber: attempts + 1 }, 'INFO');

            if (!isStrongPassword(pwd)) {
                addLog('Login Failed - Weak Password', { reason: 'Does not meet strength policy' }, 'ERROR');
                status.innerHTML = '<span class="error">Weak password! Must be 12+ chars with uppercase, lowercase, number, symbol.</span>';
                return;
            }

            if (attempts >= MAX_ATTEMPTS) {
                addLog('Account Locked - CAPTCHA Required', { failedAttempts: attempts }, 'ERROR');
                document.getElementById('loginForm').style.display = 'none';
                document.getElementById('captcha').style.display = 'block';
                generateCaptcha();
                status.innerHTML = '<span class="error">Account locked. Solve CAPTCHA to continue.</span>';
                return;
            }

            attempts++;
            const computedHash = hashPassword(username, pwd);

            if (username === demoUsername && computedHash === demoStoredHash) {
                addLog('Credentials Verified', { nextStep: 'MFA' }, 'SUCCESS');
                document.getElementById('loginForm').style.display = 'none';
                document.getElementById('mfa').style.display = 'block';
                document.getElementById('mfaCode').value = '';
                status.innerHTML = '<span class="success">Password Valid! Enter MFA code.</span>';
            } else {
                addLog('Login Failed - Invalid Credentials', {
                    usernameMatch: username === demoUsername,
                    hashMatch: computedHash === demoStoredHash,
                    attemptsRemaining: MAX_ATTEMPTS - attempts
                }, 'ERROR');
                status.innerHTML = `<span class="error">Invalid credentials (${attempts}/${MAX\_ATTEMPTS} attempts)</span>`;
            }
        });
    </script>
</body>
</html>

